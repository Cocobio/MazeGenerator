##########################################################################################################################
#
# Generated by Ignacio Osorio
#
# Backtracking algorithm implemented, using pygame as GUI
# algorithm reference: https://en.wikipedia.org/wiki/Maze_generation_algorithm#Recursive_backtracker
# solution: .............................
#
##########################################################################################################################


import pygame
import numpy as np
from BackTracker import BackTracker
import datetime
import os

# Screen size
width = 800
height = 800

# maze parameters
maze_rows = 42
maze_columns = 42

pygame.init()

# Create screen, set title and icon
screen = pygame.display.set_mode((width, height))
pygame.display.set_caption("MazeGenerator")
icon = pygame.image.load("icon.png")
pygame.display.set_icon(icon)

# Maze spects
class node: 
	def __init__(self, position):
		self.position = position

		self.north_boarder = True
		self.south_boarder = True
		self.east_boarder = True
		self.west_boarder = True

		self.neighbor = []

	def remove_wall(self, other_node):
		x = self.position[0] - other_node.position[0]
		y = self.position[1] - other_node.position[1]

		if y<0:
			self.south_boarder = False
			other_node.north_boarder = False
		elif y>0:
			self.north_boarder = False
			other_node.south_boarder = False
		elif x<0:
			self.west_boarder = False
			other_node.east_boarder = False
		elif x>0:
			self.east_boarder = False
			other_node.west_boarder = False

maze = np.empty((maze_columns, maze_rows), dtype=node)
box = pygame.Rect(0, 0, width/maze_columns, height/maze_rows)

for i in range(maze_columns):
	for j in range(maze_rows):
		maze[i][j] = node((i,j))
		if (i>0):
			maze[i][j].neighbor.append((i-1, j))
		if (i<maze_columns-1):
			maze[i][j].neighbor.append((i+1, j))
		if (j>0):
			maze[i][j].neighbor.append((i,   j-1))
		if (j<maze_rows-1):
			maze[i][j].neighbor.append((i,   j+1))

# depth first algorithm
algorithm = BackTracker(maze, box)
print(datetime.datetime.now())
running = True

while running:
	# timer
	pygame.time.wait(2)
	
	# event attender
	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			running = False
		if event.type == pygame.KEYDOWN:
			if event.key == pygame.K_PRINT:
				if not os.path.isdir('./screenshots'):
					os.mkdir('screenshots') 

				name = 'screenshots/screenshot'
				if algorithm.generated:
					name += '_generated_'
				else:
					name += '_generating_'
				name += str(datetime.datetime.now()).replace(':', '-')
				name += ".jpeg"
				pygame.image.save(screen, name)

	# Next iteration
	algorithm.iterate()

	# OpenGL Stuff
	screen.fill((255,255,255))

	algorithm.draw(screen)

	pygame.display.update()

